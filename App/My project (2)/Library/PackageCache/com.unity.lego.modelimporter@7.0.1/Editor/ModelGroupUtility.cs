// Copyright (C) LEGO System A/S - All Rights Reserved
// Unauthorized copying of this file, via any medium is strictly prohibited

using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
#if UNITY_2021_2_OR_NEWER
using UnityEditor.SceneManagement;
#else
using UnityEditor.Experimental.SceneManagement;
using UnityEditor.SceneManagement;
#endif

namespace LEGOModelImporter
{
    public class ModelGroupUtility
    {
        public enum UndoBehavior
        {
            withoutUndo,
            withUndo
        }

        static Dictionary<Brick, ModelGroup> clusterData = new Dictionary<Brick, ModelGroup>();
        static Dictionary<Model, HashSet<ModelGroup>> modelGroupParents = new Dictionary<Model, HashSet<ModelGroup>>();

        /// <summary>
        /// Create a new (auto generated) model with default values
        /// </summary>
        /// <param name="name">The name of the new model</param>
        /// <param name="undoBehavior">Whether or not to register undo for this action</param>
        /// <returns>The new model</returns>
        public static Model CreateNewDefaultModel(string name, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {
            var modelGO = new GameObject(name);
            Model model = modelGO.AddComponent<Model>();
            model.autoGenerated = true;
            model.pivot = Model.Pivot.BottomCenter;

            // Add LEGOModelAsset component.
            modelGO.AddComponent<LEGOModelAsset>();

            if (undoBehavior == UndoBehavior.withUndo)
            {
                Undo.RegisterCreatedObjectUndo(model.gameObject, "Create new model");
                Undo.RegisterCompleteObjectUndo(model, "Create new model");
            }

            //NOTE(Niels): Move newly created gameobject to the prefab stage, so that we don't get wrong OnEnable calls later
            StageUtility.PlaceGameObjectInCurrentStage(modelGO);
            return model;
        }

        /// /// <summary>
        /// Create a new (auto generated) model group with default values
        /// </summary>
        /// <param name="name">The name of the new group</param>
        /// <param name="undoBehavior">Whether or not to register undo for this action</param>
        /// <returns>The new model</returns>
        public static ModelGroup CreateNewDefaultModelGroup(string name, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {
            var groupGO = new GameObject(name);
            ModelGroup group = groupGO.AddComponent<ModelGroup>();
            group.groupName = group.name;
            group.autoGenerated = true;

            // Add LEGOModelGroupAsset component.
            groupGO.AddComponent<LEGOModelGroupAsset>();

            if (undoBehavior == UndoBehavior.withUndo)
            {
                Undo.RegisterCreatedObjectUndo(group.gameObject, "Create new model group");
                Undo.RegisterCompleteObjectUndo(group, "Create new model group");
            }

            //NOTE(Niels): Move newly created gameobject to the prefab stage, so that we don't get wrong OnEnable calls later
            StageUtility.PlaceGameObjectInCurrentStage(groupGO);
            return group;
        }

        /// <summary>
        /// Recompute the pivot of a transform containing bricks.
        /// </summary>
        /// <param name="parent">The transform to recompute the pivot for</param>
        /// <param name="pivotType">The pivot type</param>
        /// <param name="alignRotation">Whether we also want to align rotation relative to bricks</param>
        /// <param name="undoBehavior">Whether or not to register undo for this action</param>
        /// <returns>Flag indicating if pivot was recomputed</returns>
        public static bool RecomputePivot(Transform parent, Model.Pivot pivotType = Model.Pivot.BottomCenter, bool alignRotation = true, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {
            if(pivotType == Model.Pivot.Original)
            {
                return false;
            }

            var bricks = parent.GetComponentsInChildren<Brick>();
            
            Brick referenceBrick = null;
            var closestAngleToUp = 100000.0f;
            foreach (var brick in bricks)
            {
                var newAngle = Vector3.Angle(brick.transform.up, parent.up);
                if (newAngle < closestAngleToUp)
                {
                    closestAngleToUp = newAngle;
                    referenceBrick = brick;
                }
            }

            if (!referenceBrick)
            {
                return false;
            }

            var oldRotations = new List<Quaternion>();
            var oldPositions = new List<Vector3>();

            Vector3 pivot;

            if(pivotType == Model.Pivot.BottomCenter)
            {
                var closestAxis = MathUtils.FindClosestAxis(referenceBrick.transform, parent.up, out var axis);
                var (newRight, newForward) = MathUtils.GetRelatedAxes(referenceBrick.transform, axis);

                Matrix4x4 m = Matrix4x4.identity;
                m.SetColumn(0, newRight);
                m.SetColumn(1, closestAxis);
                m.SetColumn(2, newForward);

                var bounds = BrickBuildingUtility.ComputeBounds(bricks, m.inverse);
                pivot = bounds.center;

                pivot -= Vector3.up * bounds.extents.y;
                pivot = m.MultiplyPoint(pivot);
            }
            else
            {
                var bounds = BrickBuildingUtility.ComputeBounds(bricks);
                pivot = bounds.center;
            }

            if (Vector3.Distance(parent.position, pivot) < 0.1f)
            {
                return false;
            }

            if(undoBehavior == UndoBehavior.withUndo)
            {
                Undo.RegisterFullObjectHierarchyUndo(parent.gameObject, "Recording groups before moving model group");
            }

            var difference = parent.position - pivot;
            parent.position = pivot;
            foreach (Transform child in parent)
            {
                child.position += difference;
                if(alignRotation)
                {
                    oldRotations.Add(child.transform.rotation);
                    oldPositions.Add(child.transform.position);
                }
            }

            if (alignRotation)
            {
                var up = referenceBrick.transform.up;
                var right = referenceBrick.transform.right;
                var forward = referenceBrick.transform.forward;

                var closest = MathUtils.FindClosestAxis(parent, up, out MathUtils.VectorDirection direction);
                var rot = Quaternion.FromToRotation(closest, up);

                var oldRot = parent.rotation;
                parent.rotation = rot * parent.rotation;

                var m = Matrix4x4.TRS(parent.position, Quaternion.identity, Vector3.one);
                m.SetColumn(0, forward);
                switch(direction)
                {
                    case MathUtils.VectorDirection.Up:
                    m.SetColumn(1, parent.up);
                    break;
                    case MathUtils.VectorDirection.Right:
                    m.SetColumn(1, parent.right);
                    break;
                    case MathUtils.VectorDirection.Forward:
                    m.SetColumn(1, parent.forward);
                    break;
                    case MathUtils.VectorDirection.Down:
                    m.SetColumn(1, -parent.up);
                    break;
                    case MathUtils.VectorDirection.Left:
                    m.SetColumn(1, -parent.right);
                    break;
                    case MathUtils.VectorDirection.Back:
                    m.SetColumn(1, -parent.forward);
                    break;
                }
                m.SetColumn(2, right);

                var related = MathUtils.GetRelatedAxes(parent, direction);
                rot = MathUtils.AlignRotation(m, related.Item1, related.Item2) * rot;
                rot.ToAngleAxis(out float angle, out Vector3 axis);
                parent.rotation = oldRot;
                parent.RotateAround(parent.position, axis, angle);

                var i = 0;
                foreach(Transform child in parent)
                {
                    child.transform.rotation = oldRotations[i];
                    child.transform.position = oldPositions[i++];
                }
            }

            return true;
        }

        /// <summary>
        /// Recompute pivot for a model according to the pivot type set on the model
        /// </summary>
        /// <param name="model">The model to recompute pivot for</param>
        /// <param name="alignRotation">Whether or not to align the rotation according to the bricks in the model</param>
        /// <param name="undoBehavior">Whether or not to register undo for this action</param>
        public static bool RecomputePivot(Model model, bool alignRotation = true, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {
            return RecomputePivot(model.transform, model.pivot, alignRotation, undoBehavior);
        }

        /// <summary>
        /// Recompute pivot for a model group according to the pivot type set on the model
        /// </summary>
        /// <param name="model">The model group to recompute pivot for</param>
        /// <param name="alignRotation">Whether or not to align the rotation according to the bricks in the model group</param>
        /// <param name="undoBehavior">Whether or not to register undo for this action</param>
        public static bool RecomputePivot(ModelGroup group, bool alignRotation = true, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {
            return RecomputePivot(group.transform, Model.Pivot.BottomCenter, alignRotation, undoBehavior);
        }

        public static void SetParent(Transform transform, Transform parent, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {            
            if(transform.parent == parent)
            {
                return;
            }

            if (undoBehavior == UndoBehavior.withUndo)
            {
                Undo.SetTransformParent(transform, parent, "Setting transform parent");
            }
            else
            {
                transform.SetParent(parent, true);
            }
        }

        public static void DestroyObject(GameObject go, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {
            if (undoBehavior == UndoBehavior.withUndo)
            {
                Undo.DestroyObjectImmediate(go);                
            }
            else
            {
                Object.DestroyImmediate(go);
            }
        }

        public static void DestroyObjects(ICollection<GameObject> gameObjects, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {
            foreach(var go in gameObjects)
            {
                if (!go) continue;
                if (undoBehavior == UndoBehavior.withUndo)
                {
                    Undo.DestroyObjectImmediate(go);
                }
                else
                {
                    Object.DestroyImmediate(go);
                }
            }
        }

        private static bool IsPartOfPrefabInstance(Brick brick)
        {
            return brick.transform.parent && PrefabUtility.IsPartOfPrefabInstance(brick.transform.parent) && !PrefabUtility.IsAddedGameObjectOverride(brick.gameObject);
        }

        private static void UnpackPrefab(Brick brick, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {
            UnpackPrefab(brick.gameObject, undoBehavior);
        }

        private static void UnpackPrefab(GameObject gameObject, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {
            var root = PrefabUtility.GetOutermostPrefabInstanceRoot(gameObject);
            if(undoBehavior == UndoBehavior.withUndo)
            {
                Undo.RegisterCompleteObjectUndo(root, $"Unpacking {root}");
            }
            PrefabUtility.UnpackPrefabInstance(root, PrefabUnpackMode.OutermostRoot, undoBehavior == UndoBehavior.withUndo ? InteractionMode.UserAction : InteractionMode.AutomatedAction);
        }

        private static ModelGroup GetGroupInParent(GameObject go)
        {
            return go.GetComponentInParent<ModelGroup>(true);
        }

        private static Model GetModelInParent(GameObject go)
        {
            return go.GetComponentInParent<Model>(true);
        }       

        /// <summary>
        /// Recompute the model and model group hierarchy.
        /// Some rules:
        /// 1. A brick will always be in a model group, which will always be in a model.
        /// 2. Empty models and model groups are destroyed.
        /// 3. Bricks can not contain bricks, model groups can not contain model groups and models can not contain models. So they are flattened.
        /// 4. Bricks will be grouped together with connected bricks.
        /// @Performance(Niels): Consider the use of multiple new hash sets, lists etc. and create these beforehand, and only clear.
        /// </summary>
        /// <param name="bricks">The bricks that we need to check the hierarchy for</param>
        /// <param name="alignRotation">Whether or not we also align rotation when we recompute pivot</param>
        /// <param name="undoBehavior">Whether or not to register undo for the recomputation of hierarchy</param>
        public static void RecomputeHierarchy(IEnumerable<Brick> bricks, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {
            // Group numbers are numbers in parentheses
            // So group 1 with three bricks is shown as (1, 1, 1) 
            // In case the group is part of a prefab it is suffixed with a p like (1p, 1p)
            // In case one of the bricks in a group is an override it is noted with a + as in (1p, 1p+)

            // Cases for splitting:
            // (1, 1) -> (1) (1)
            // (1, 1) (2) -> (1) (1, 2) -> (1) (2, 2)

            // Cases for unpacking:
            // (1p) (2p) -> (1, 2p) -> (2p+, 2p)
            // (1p, 1p+) (2p) -> (1, 1, 2p) -> (2p+, 2p+, 2p)
            // (1p, 1p) -> (1p) (1p) -> (1) (1)

            // Only set parent:
            // (1) (2) -> (1, 2) -> (2, 2)
            // (1p, 1p+) (2p) -> (1p) (1p+, 2p) -> (1p) (2p+, 2p)
            // (1p, 1p+) (2) -> (1p) (1p+, 2) -> (1p) (2, 2)

            if(PrefabStageUtility.GetCurrentPrefabStage() != null)
            {
                GameObject rootObject = PrefabStageUtility.GetCurrentPrefabStage().prefabContentsRoot;
                Brick brick = rootObject.GetComponent<Brick>();
                if(brick)
                {                    
                    return;
                }

                ModelGroup modelGroup = rootObject.GetComponent<ModelGroup>();
                if(modelGroup)
                {
                    return;
                }
            }

            clusterData.Clear();
            modelGroupParents.Clear();

            // First we flatten models
            var modelsToCheck = new HashSet<Model>();
            var groupsToCheck = new HashSet<ModelGroup>();
            var bricksToCheck = new HashSet<Brick>();

            foreach(var brick in bricks)
            {
                var bricksInParent = brick.GetComponentsInParent<Brick>(true);
                if(bricksInParent.Length > 1)
                {
                    bricksToCheck.Add(brick);
                }
                var modelsInParent = brick.GetComponentsInParent<Model>(true);
                if(modelsInParent.Length > 1)
                {
                    modelsToCheck.UnionWith(modelsInParent);
                }
                var groupsInParent = brick.GetComponentsInParent<ModelGroup>(true);
                if(groupsInParent.Length > 1)
                {
                    groupsToCheck.UnionWith(groupsInParent);
                }
            }

            foreach(var model in modelsToCheck)
            {
                var modelsInModel = model.GetComponentsInChildren<Model>(true);
                foreach(var inModel in modelsInModel)
                {
                    if (inModel == model)
                    {
                        continue;
                    }

                    var groupsInModel = inModel.GetComponentsInChildren<ModelGroup>();
                    foreach (var group in groupsInModel)
                    {
                        SetParent(group.transform, model.transform, undoBehavior);
                    }
                }
            }

            // Now flatten groups
            foreach(var group in groupsToCheck)
            {
                var groupsInGroup = group.GetComponentsInChildren<ModelGroup>(true);
                foreach(var inGroup in groupsInGroup)
                {
                    if(inGroup == group)
                    {
                        continue;
                    }

                    var bricksInGroup = inGroup.GetComponentsInChildren<Brick>(true);
                    foreach(var brick in bricksInGroup)
                    {
                        clusterData[brick] = group;
                    }
                }
            }

            // Now flatten bricks
            foreach(var brick in bricksToCheck)
            {
                var group = GetGroupInParent(brick.gameObject);
                if(group)
                {
                    clusterData[brick] = group;
                }
            }
            
            var connectedClusters = new List<List<Brick>>();
            var checkedBricks = new HashSet<Brick>();

            // Collect all connected brick lists
            foreach(var brick in bricks)
            {
                if (!brick) continue;
                if(checkedBricks.Contains(brick))
                {
                    continue;
                }                

                if(!brick.HasConnectivity())
                {
                    var group = GetGroupInParent(brick.gameObject);
                    var model = GetModelInParent(brick.gameObject);
                    if(!group || !model)
                    {
                        connectedClusters.Add(new List<Brick>{brick});
                    }
                    checkedBricks.Add(brick);
                }
                else
                {
                    var connected = brick.GetConnectedBricks();
                    connected.Add(brick);

                    var list = new List<Brick>();
                    foreach(var c in connected)
                    {
                        if(checkedBricks.Contains(c))
                        {
                            break;
                        }
                        list.Add(c);
                        checkedBricks.Add(c);
                    }
                    
                    if(list.Count == 0)
                    {
                        continue;
                    }
                    connectedClusters.Add(list);
                }
            }
            checkedBricks.Clear();

            var groupsToMerge = new List<(List<Brick>, HashSet<ModelGroup>)>();
            var groupsToSplitWorkList = new List<(List<Brick>, ModelGroup, HashSet<Brick>)>();
            var checkedGroups = new HashSet<ModelGroup>();
            var noGroup = new List<Brick>();

            foreach(var cluster in connectedClusters)
            {
                if(cluster.Count == 0)
                {
                    continue;
                }

                var bricksNotInGroup = new HashSet<Brick>();
                var groups = new HashSet<ModelGroup>();
                foreach(var brick in cluster)
                {
                    var group = GetGroupInParent(brick.gameObject);                    
                    if(group)
                    {
                        groups.Add(group);
                    }
                    else
                    {
                        bricksNotInGroup.Add(brick);
                    }
                }

                if(groups.Count > 1)
                {
                    groupsToMerge.Add((cluster, groups));
                }
                else if(groups.Count == 1)
                {
                    var it = groups.GetEnumerator();
                    it.MoveNext();
                    ModelGroup group = it.Current;
                    if(!checkedGroups.Contains(group))
                    {
                        groupsToSplitWorkList.Add((cluster, group, bricksNotInGroup));
                        checkedGroups.Add(group);
                    }
                }
                else
                {
                    foreach(var b in bricksNotInGroup)
                    {
                        noGroup.Add(b);
                    }
                }
            }

            foreach(var toMerge in groupsToMerge)
            {
                List<Brick> cluster = toMerge.Item1; // All the bricks that are connected
                HashSet<ModelGroup> groups = toMerge.Item2; // The groups for this cluster
                
                // Merge some groups
                ModelGroup largestGroup = null;
                int largestGroupSize = 0;
                foreach (var group in groups)
                {
                    Brick[] bricksInGroup = group.GetComponentsInChildren<Brick>(true);
                    int bricksInCluster = 0;
                    bool fullyContained = true;
                    for(int i = 0; i < bricksInGroup.Length; i++)
                    {
                        if(cluster.Contains(bricksInGroup[i]))
                        {
                            bricksInCluster++;
                        }
                        else
                        {
                            fullyContained = false;
                            break;
                        }
                    }

                    if(!fullyContained)
                    {
                        continue;
                    }

                    if (bricksInCluster >= largestGroupSize)
                    {
                        largestGroup = group;
                        largestGroupSize = bricksInCluster;
                    }
                }
                
                if(largestGroup)
                {
                    foreach(var brick in cluster)
                    {
                        if(checkedBricks.Contains(brick))
                        {
                            continue;
                        }

                        if (brick.transform.parent == largestGroup.transform)
                        {
                            continue;
                        }

                        if(IsPartOfPrefabInstance(brick))
                        {
                            UnpackPrefab(brick, undoBehavior);
                        }
                        checkedBricks.Add(brick);
                        clusterData[brick] = largestGroup;
                    }
                }
            }

            void ProcessClusterData()
            {
                foreach(var pair in clusterData)
                {
                    var brick = pair.Key;
                    var group = pair.Value;
                    SetParent(brick.transform, group.transform, undoBehavior);
                }

                foreach (var pair in modelGroupParents)
                {
                    var model = pair.Key;
                    var groups = pair.Value;
                    foreach (var group in groups)
                    {
                        if (!model) continue;
                        if (!group) continue;
                        SetParent(group.transform, model.transform, undoBehavior);
                    }
                }
                clusterData.Clear();
                modelGroupParents.Clear();
            }

            ProcessClusterData();

            foreach(var toSplit in groupsToSplitWorkList)
            {
                List<Brick> cluster = toSplit.Item1; // All the bricks that are connected
                ModelGroup group = toSplit.Item2; // The groups for this cluster
                HashSet<Brick> notInGroup = toSplit.Item3; // The bricks that are not yet contained in a group

                var bricksInGroup = group.GetComponentsInChildren<Brick>(true);
                var clustersForGroup = new List<List<Brick>>();

                // If this group contains more than one cluster, split
                foreach (var brick in bricksInGroup)
                {                        
                    if (brick.HasConnectivity())
                    {
                        if(checkedBricks.Contains(brick))
                        {
                            continue;
                        }

                        var connected = brick.GetConnectedBricks();
                        connected.Add(brick);

                        var list = new List<Brick>();
                        foreach(var c in connected)
                        {                                
                            if(checkedBricks.Contains(c))
                            {
                                break;
                            }
                            list.Add(c);
                            checkedBricks.Add(c);
                        }
                        
                        if(list.Count == 0)
                        {
                            continue;
                        }
                        clustersForGroup.Add(list);
                    }
                }

                // Only split if we found multiple clusters in group
                if (clustersForGroup.Count > 1)
                {
                    // Get the model for the group
                    var model = GetModelInParent(group.gameObject);
                    if(model)
                    {
                        if(!modelGroupParents.ContainsKey(model))
                        {
                            modelGroupParents[model] = new HashSet<ModelGroup>();
                        }
                    }

                    // Find all prefabs we need to unpack by looking through the clusters in the group
                    foreach (var clusterInGroup in clustersForGroup)
                    {
                        bool unpacked = false;
                        // Look through each brick in the cluster
                        foreach (var brick in clusterInGroup)
                        {
                            if(unpacked)
                            {
                                break;
                            }

                            // First check if there is a brick in this cluster that is part of a prefab and not an override
                            // If there is, then check if there is another cluster containing a prefab that is not an override
                            // In that case, we have to unpack, because we are changing the parents of gameobjects in a prefab
                            if (IsPartOfPrefabInstance(brick))
                            {                                    
                                foreach(var clust in clustersForGroup)
                                {                                        
                                    if(unpacked)
                                    {
                                        break;
                                    }

                                    if(clust == clusterInGroup)
                                    {
                                        continue;
                                    }

                                    foreach(var c in clust)
                                    {
                                        if(!PrefabUtility.IsAddedGameObjectOverride(c.gameObject))
                                        {
                                            UnpackPrefab(brick, undoBehavior);
                                            unpacked = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Optimization: Check for largest group containing only a single cluster and keep that group intact
                    int largestGroupIndex = -1;
                    int largestGroupSize = 0;
                    ModelGroup largestGroup = null;

                    for(var i = 0; i < clustersForGroup.Count; i++)
                    {
                        var clusterInGroup = clustersForGroup[i];
                        var parent = clusterInGroup[0].transform.parent; // Get the group from the first brick
                        if (!parent)
                        {
                            continue;
                        }
                        var modelGroup = parent.GetComponent<ModelGroup>();   

                        var skip = false;
                        foreach (var brick in clusterInGroup)
                        {
                            if (brick.transform.parent != parent)
                            {
                                skip = true;
                                break;
                            }
                        }

                        if (skip)
                        {
                            continue;
                        }                          

                        if (largestGroupSize < clusterInGroup.Count)
                        {                                
                            largestGroupSize = clusterInGroup.Count;
                            largestGroupIndex = i;
                            largestGroup = modelGroup;
                        }
                    }

                    if (largestGroupIndex != -1)
                    {
                        clustersForGroup.RemoveAt(largestGroupIndex);
                    }

                    foreach (var clusterInGroup in clustersForGroup)
                    {
                        bool valid = false;
                        foreach(var brick in clusterInGroup)
                        {
                            if(!clusterData.ContainsKey(brick))
                            {
                                valid = true;
                                break;
                            }
                        }

                        if(valid)
                        {
                            var newGroup = CreateNewDefaultModelGroup(group.groupName, undoBehavior);

                            newGroup.transform.position = group.transform.position;

                            newGroup.name = group.groupName;
                            newGroup.groupName = group.groupName;
                            newGroup.parentName = group.parentName;
                            newGroup.optimizations = group.optimizations;
                            newGroup.randomizeNormals = group.randomizeNormals;
                            foreach (var view in group.views)
                            {
                                newGroup.views.Add(new CullingCameraConfig()
                                {
                                    name = view.name,
                                    perspective = view.perspective,
                                    position = view.position,
                                    rotation = view.rotation,
                                    fov = view.fov,
                                    size = view.size,
                                    minRange = view.minRange,
                                    maxRange = view.maxRange,
                                    aspect = view.aspect
                                });
                            }
                            newGroup.autoGenerated = true;
                            var clusterSet = new HashSet<Brick>();

                            foreach (var brick in clusterInGroup)
                            {
                                clusterSet.Add(brick);
                                clusterData[brick] = newGroup;
                            }

                            if (model)
                            {
                                modelGroupParents[model].Add(newGroup);
                            }
                        }
                    }
                }
                else if (notInGroup.Count > 0)
                {
                    foreach (var brick in notInGroup)
                    {
                        if (IsPartOfPrefabInstance(brick))
                        {
                            UnpackPrefab(brick, undoBehavior);
                        }
                        clusterData[brick] = group;
                    }
                }
                else
                {
                    var modelTransform = group.transform.parent;
                    bool inPrefabStage = PrefabStageUtility.GetCurrentPrefabStage() != null;
                    bool createNewModel = (inPrefabStage && modelTransform && !modelTransform.GetComponent<Model>())
                                        || (!inPrefabStage && (!modelTransform || !modelTransform.GetComponent<Model>()));

                    if(createNewModel)
                    {
                        Model model = CreateNewDefaultModel(group.name, undoBehavior);
                        if(modelTransform != null)
                        {
                            if (!inPrefabStage && PrefabUtility.IsPartOfPrefabInstance(modelTransform))
                            {
                                UnpackPrefab(modelTransform.gameObject, undoBehavior);
                            }
                        }
                        if(!modelGroupParents.ContainsKey(model))
                        {
                            modelGroupParents[model] = new HashSet<ModelGroup>();
                        }
                        modelGroupParents[model].Add(group);
                    }
                }
            }

            ProcessClusterData();

            if(noGroup.Count > 0)
            {
                var first = noGroup[0];
                string name = "";
                if (first)
                {
                    name = first.name;
                }
                Model model;

                if (PrefabStageUtility.GetCurrentPrefabStage() != null)
                {
                    var rootObject = PrefabStageUtility.GetCurrentPrefabStage().prefabContentsRoot;
                    model = rootObject.GetComponent<Model>();
                    if (!model)
                    {
                        model = CreateNewDefaultModel(name);
                        SetParent(model.transform, rootObject.transform, undoBehavior);
                    }
                }
                else
                {
                    model = CreateNewDefaultModel(name);
                }

                ModelGroup newGroup = CreateNewDefaultModelGroup(name);
                if(!modelGroupParents.ContainsKey(model))
                {
                    modelGroupParents[model] = new HashSet<ModelGroup>();
                }

                modelGroupParents[model].Add(newGroup);
                var bounds = BrickBuildingUtility.ComputeBounds(noGroup, Matrix4x4.identity);
                model.transform.position = new Vector3(bounds.center.x, bounds.min.y, bounds.center.z);

                Transform originalParent = null;
                foreach (var brick in noGroup)
                {
                    if (!originalParent)
                    {
                        originalParent = brick.transform.parent;
                    }
                    if (brick.transform.parent != originalParent)
                    {
                        originalParent = null;
                        break;
                    }
                }

                if (originalParent)
                {
                    SetParent(model.transform, originalParent, undoBehavior);
                }

                foreach (var brick in noGroup)
                {
                    clusterData[brick] = newGroup;
                }
            }

            ProcessClusterData();
        }
    }
}
